ll binary_exponentiation(const ll &a,const ll &n)
{
    if(n == 0)
    return 1;
    if(n & 1)
    return (a % inf) * (binary_exponentiation((a % inf) * (a % inf) % inf,n / 2) % inf) % inf;
    return binary_exponentiation((a % inf) * (a % inf) % inf,n / 2) % inf;
}

void sieve_of_eratosthenes(vb &prime)
{
    prime[1] = false;
    for(int p = 2; p <= 1000; ++p)
    {
        if(!prime.at(p))
        continue;
        for(int q = p * p; q <= 1000000; q += p)
        prime.at(q) = false;
    }
}

string add(string num1,string num2,int base)
{
    string A,B,result;
    if(num1.length() > num2.length())
    {
        A = num1;
        B = num2;
    }
    else
    {
        A = num2;
        B = num1;
    }
    reverse(A.begin(),A.end());
    reverse(B.begin(),B.end());
    int carry = 0;
    for(int i = 0; A[i]; ++i)
    if(B[i] == '\0')
    {
        while(A[i])
        {
            int a = A[i] - '0';
            int sum = a + carry;
            result.push_back(sum % base + '0');
            carry = sum / base;
            i++;    
        }
        break;
    }
    else
    {
        int a = A[i] - '0';
        int b = B[i] - '0';
        int sum = a + b + carry;
        result.push_back(sum % base + '0');
        carry = sum / base;
    }
    if(carry > 0)
    result.push_back(carry + '0');
    reverse(result.begin(),result.end());
    return result;
}



typedef struct Segment_Tree
{
    int left_index,right_index,val;
    struct Segment_Tree *left_child,*right_child;
}Segment_Tree;

Segment_Tree * create_segment_tree(int l,int r,vi &vec)
{
    Segment_Tree * temp = new Segment_Tree();
    temp->left_index = l;
    temp->right_index = r;
    if(l == r)
    temp->val = vec.at(l),temp->left_child = temp->right_child = nullptr;
    else
    {
        temp->left_child = create_segment_tree(l,(l + r) / 2,vec);
        temp->right_child = create_segment_tree((l + r) / 2 + 1,r,vec);
        temp->val = temp->left_child->val + temp->right_child->val;
    }
    return temp;
}

Segment_Tree * update(Segment_Tree *root,int index,int val)
{
    if(root->left_index == root->right_index && root->left_index == index)
    root->val += val;
    else if(index <= root->right_index && index >= root->left_index)
    {
        root->left_child = update(root->left_child,index,val);
        root->right_child = update(root->right_child,index,val);
        root->val = root->left_child->val + root->right_child->val;
    }
    return root;
}

int Segment_Tree_query(Segment_Tree * root,int l,int r)
{
    if(root->left_index > r || root->right_index < l)
    return 0;
    else if(root->left_index >= l && root->right_index <= r)
    return root->val;
    else
    return Segment_Tree_query(root->left_child,l,r) + Segment_Tree_query(root->right_child,l,r);
}


void dijkstra(vvpii &city,int src)
{
    pqpii pq;
    pq.push({0,src});
    vi dist(city.size(),INT_MAX),path;
    vb spt(city.size());
    dist[src] = 0;
    path.push_back(src);
    spt[src] = true;
    while(!pq.empty())
    {
        for(pii node:city[src])
        {
            if(spt[node.first] == false && dist[src] + node.second < dist[node.first])
            dist[node.first] = dist[src] + node.second,pq.push({dist[node.first],node.first});
        }
        while(!pq.empty())
        {
            pii temp = pq.top();
            if(spt[temp.second] == false)
            {
                spt[temp.second] = true;
                src = temp.second;
                path.push_back(src);
                break;
            }
            pq.pop();
        }
    } 
}


int dsu_root(vi &vec,int i)
{
    while(vec[i] != i)
    {
        vec[i] = vec[vec[i]];
        i = vec[i];
    }
    return i;
}


void dsu_union_find(vi &arr,vi &size,int a,int b)
{
    int root_a = dsu_root(arr,a);
    int root_b = dsu_root(arr,b);
    if(root_a == root_b)
        return;
    if(size[root_a] < size[root_b])
    {
        size[root_b] += size[root_a];
        arr[root_a] = root_b;
    }
    else
    {
        size[root_a] += size[root_b];
        arr[root_b] = root_a;
    }
}


void merge(vi &vec,vi &left,vi &right,int left_size,int right_size)
{
    int le = 0, ri = 0;
    f(i,0,left_size + right_size)
    if(left.at(le) < right.at(ri))
    {
        vec.at(i) = left.at(le);
        le++;
        if(le == left_size)
        {
            while(ri != right_size)
            vec.at(++i) = right.at(ri++);
            break;
        }
    }
    else
    {
        vec.at(i) = right.at(ri);
        ri++;
        if(ri == right_size)
        {
        while(le != left_size)
        vec.at(++i) = left.at(le++);
        break;
        }
    }
}

void merge_sort(vi &vec,int l,int r)
{
    if(l == r)
    return;
    int mid = (l + r) / 2;
    vi left(mid+1);
    vi right(r-mid);
    f(i,0,mid+1)
    left.at(i) = vec.at(i);
    f(i,mid+1,r+1)
    right.at(i-mid-1) = vec.at(i);
    merge_sort(left,0,mid);
    merge_sort(right,0,r-mid-1);
    merge(vec,left,right,mid + 1,r-mid);
}

int mul(vvi &A, vvi &B, int i, int j, int k)
{
    int sum = 0;
    f(t,0,k)
    sum = (sum % inf + (1LL * (A[i][t] % inf) * (B[t][j] % inf)) % inf) % inf;
    return sum;
}
 
vvi multiply(vvi &A,vvi &B)
{
    vvi result(A.size(),vi(A.size()));
    f(i,0,A.size())
    f(j,0,B.size())
    result[i][j] = mul(A,B,i,j,A.size());
    return result;
}
 
 
vvi matrix_exponentiation(vvi &matrix,int n)
{
    if(n == 0)
    {
        vvi identity_matrix(matrix.size(),vi(matrix.size()));
        f(i,0,matrix.size())
        identity_matrix[i][i] = 1;
        return identity_matrix;
    }
    vvi temp(matrix.size(),vi(matrix.size()));
    temp = multiply(matrix,matrix);
    vvi mat(matrix.size(),vi(matrix.size()));
    mat = matrix_exponentiation(temp,n / 2);
    if(n & 1) 
    return multiply(matrix,mat);
    return mat;
}


void articulation_points(int src, vvi &graph, vi &disc, vi &low, vb &visited, vb &ap, vi &parent)
{
    int child = 0;
    visited[src] = true;
    disc[src] = low[src] = ++discovery_time;
    for (int node : graph[src])
    if (visited[node])
    {
        if (node ^ parent[src])
        low[src] = min(low[src], disc[node]);
    }
    else
    {
        ++child;
        parent[node] = src;
        articulation_points(node, graph, disc, low, visited, ap, parent);
        low[src] = min(low[src], low[node]);
        if (parent[src] == -1)
        {
            if (child > 1)
            ap[src] = true;
        }
        else if (low[node] >= disc[src])
        ap[src] = true;
    }
}
