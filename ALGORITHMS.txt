ll binary_exponentiation(const ll &a,const ll &n)
{
    if(n == 0)
    return 1;
    if(n & 1)
    return (a % inf * binary_exponentiation((a % inf * a % inf) % inf,n / 2) % inf) % inf;
    else
    return binary_exponentiation((a % inf * a % inf) % inf,n / 2) % inf;
}

void sieve_of_eratosthenes()
{
    vb prime(1000001,true);
    prime[1] = false;
    for(int p = 2; p <= 1000; ++p)
    {
        if(!prime.at(p))
        continue;
        for(int q = p * p; q <= 1000000; q += p)
        prime.at(q) = false;
    }
}

string add(string num1,string num2,int base)
{
    string A,B,result;
    if(num1.length() > num2.length())
    {
        A = num1;
        B = num2;
    }
    else
    {
        A = num2;
        B = num1;
    }
    reverse(A.begin(),A.end());
    reverse(B.begin(),B.end());
    int carry = 0;
    for(int i = 0; A[i]; ++i)
    if(B[i] == '\0')
    {
        while(A[i])
        {
            int a = A[i] - '0';
            int sum = a + carry;
            result.push_back(sum % base + '0');
            carry = sum / base;
            i++;    
        }
        break;
    }
    else
    {
        int a = A[i] - '0';
        int b = B[i] - '0';
        int sum = a + b + carry;
        result.push_back(sum % base + '0');
        carry = sum / base;
    }
    if(carry > 0)
    result.push_back(carry + '0');
    reverse(result.begin(),result.end());
    return result;
}



typedef struct Segment_Tree
{
    int left_index,right_index;
    ll val;
    struct Segment_Tree *left_child = nullptr,*right_child = nullptr;
}Segment_Tree;

Segment_Tree * create_segment_tree(int l,int r,vi &vec)
{
    Segment_Tree * temp = new Segment_Tree();
    temp->left_index = l;
    temp->right_index = r;
    if(l == r)
    temp->val = vec.at(l);
    else
    {
        temp->left_child = create_segment_tree(l,(l + r) / 2,vec);
        temp->right_child = create_segment_tree((l + r) / 2 + 1,r,vec);
        temp->val = temp->left_child->val + temp->right_child->val;
    }
    return temp;
}

Segment_Tree * update(Segment_Tree *root,int index,int val)
{
    if(root->left_index == root->right_index && root->left_index == index)
    root->val += val;
    else if(index <= root->right_index && index >= root->left_index)
    {
        root->left_child = update(root->left_child,index,val);
        root->right_child = update(root->right_child,index,val);
        root->val = root->left_child->val + root->right_child->val;
    }
    return root;
}

ll Segment_Tree_sum(Segment_Tree * root,int l,int r)
{
    if(root->left_index > r || root->right_index < l)
    return 0;
    else if(root->left_index >= l && root->right_index <= r)
    return root->val;
    else
    return Segment_Tree_sum(root->left_child,l,r) + Segment_Tree_sum(root->right_child,l,r);
}


void dijkstra(vvpii &city,int src)
{
    pqpii pq;
    pq.push({0,src});
    vi dist(city.size()+1,INT_MAX),path(city.size()+1);
    vb spt(city.size()+1);
    dist[src] = 0;
    path[src] = src;
    spt[src] = true;
    while(!pq.empty())
    {
        for(pii node:city[src])
        {
            if(spt[node.first] == false && dist[src] + node.second < dist[node.first])
            dist[node.first] = dist[src] + node.second,path[node.first] = src,pq.push({dist[node.first],node.first});
        }
        while(!pq.empty())
        {
            pii temp = pq.top();
            if(spt[temp.second] == false)
            {
                spt[temp.second] = true;
                src = temp.second;
                break;
            }
            pq.pop();
        }
    } 
}


int dsu_root(vi &vec,int i)
{
    while(vec[i] != i)
    {
        vec[i] = vec[vec[i]];
        i = vec[i];
    }
    return i;
}


void dsu_union_find(vi &arr,vi &size,int a,int b)
{
    int root_a = dsu_root(arr,a);
    int root_b = dsu_root(arr,b);
    if(root_a == root_b)
        return;
    if(size[root_a] < size[root_b])
    {
        size[root_b] += size[root_a];
        arr[root_a] = root_b;
    }
    else
    {
        size[root_a] += size[root_b];
        arr[root_b] = root_a;
    }
}
