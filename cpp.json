{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Competitive programming template":{
	"prefix": "my_template",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"#define inf 1000000007",
		"#define ll long long int",
		"#define vi vector<int>",
		"#define vb vector<bool>",
		"#define vc vector<char>",
		"#define vvc vector< vector<char> >",
		"#define vvi vector< vector<int> >",
		"#define vvb vector< vector<bool> >",
		"#define vvpii vector< vector< pair<int,int> > >",
		"#define vll vector<long long int>",
		"#define all(x) x.begin(),x.end()",
		"#define pii pair<int,int>",
		"#define pqpii priority_queue< pair<int,int> ,vector< pair<int,int> >,greater< pair<int,int> > >",
		"#define f(i,a,b) for(int i = a; i < b; ++i)",
		"#define fr(i,a,b) for(int i = a; i > b; --i)", 
		"\n\n\n\n\n\n",
		"int main()",
		"{",
    	"\tios_base::sync_with_stdio(false);",
    	"\tcin.tie(NULL);",
    	"\tcout.tie(NULL);",
    	"\tint t;",
    	"\tcin >> t;",
    	"\twhile (t--)",
    	"\t{",
        "",
    	"\t}",
    	"\treturn 0;",
		"}"
	]
	},
	"ALGORITHMS_BINARY_EXPONENTIATION":{
		"prefix": "binary_exponentiation",
		"body": [
			"ll binary_exponentiation(const ll &a,const ll &n)",
			"{",
    		"\tif(n == 0)",
    		"\treturn 1;",
    		"\tif(n & 1)",
    		"\treturn (a % inf) * (binary_exponentiation((a % inf) * (a % inf) % inf,n / 2) % inf) % inf;",
    		"\treturn binary_exponentiation((a % inf) * (a % inf) % inf,n / 2) % inf;",
			"}"
		]
	},
	"ALGORITHMS_DSU_ROOT":{
		"prefix": "dsu_root",
		"body": [
			"int dsu_root(vi &vec,int i)",
			"{",
    		"\twhile(vec[i] != i)",
    		"\t{",
        	"\t\tvec[i] = vec[vec[i]];",
        	"\t\ti = vec[i];",
    		"\t}",
    		"\treturn i;",
			"}"
		]
	},
	"ALGORITHMS_DSU_UNION_FIND":{
		"prefix": "dsu_union_find",
		"body": [
			"void dsu_union_find(vi &arr,vi &size,int a,int b)",
			"{",
    		"\tint root_a = dsu_root(arr,a);",
    		"\tint root_b = dsu_root(arr,b);",
    		"\tif(root_a == root_b)",
        	"\treturn;",
    		"\tif(size[root_a] < size[root_b])",
    		"\t{",
        	"\t\tsize[root_b] += size[root_a];",
        	"\t\tarr[root_a] = root_b;",
    		"\t}",
    		"\telse",
    		"\t{",
        	"\t\tsize[root_a] += size[root_b];",
        	"\t\tarr[root_b] = root_a;",
    		"\t}",
			"}"
		]
	},
	"ALGORITHMS_SIEVE_OF_ERATOSTHENES":{
		"prefix": "sieve_of_eratosthenes",
		"body": [
			"void sieve_of_eratosthenes(vb &prime)",
			"{",
    		"\tprime[1] = false;",
    		"\tfor(int p = 2; p <= 1000; ++p)",
    		"\t{",
        	"\t\tif(!prime.at(p))",
        	"\t\tcontinue;",
        	"\t\tfor(int q = p * p; q <= 1000000; q += p)",
        	"\t\tprime.at(q) = false;",
    		"\t}",
			"}"
		]
	},
	"ALGORITHMS_DIJKSTRA":{
		"prefix": "dijkstra",
		"body": [
			"void dijkstra(vvpii &city,int src)",
			"{",
    		"\tpqpii pq;",
    		"\tpq.push({0,src});",
    		"\tvi dist(city.size(),INT_MAX),path;",
    		"\tvb spt(city.size());",
    		"\tdist[src] = 0;",
			"\tpath.push_back(src);",
    		"\tspt[src] = true;",
    		"\twhile(!pq.empty())",
    		"\t{",
        	"\t\tfor(pii node:city[src])",
        	"\t\t{",
            "\t\t\tif(spt[node.first] == false && dist[src] + node.second < dist[node.first])",
            "\t\t\tdist[node.first] = dist[src] + node.second,pq.push({dist[node.first],node.first});",
        	"\t\t}",
        	"\t\twhile(!pq.empty())",
        	"\t\t{",
            "\t\t\tpii temp = pq.top();",
            "\t\t\tif(spt[temp.second] == false)",
            "\t\t\t{",
            "\t\t\t\tspt[temp.second] = true;",
            "\t\t\t\tsrc = temp.second;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tpq.pop();",
        	"\t\t}",
    		"\t}", 
			"}"
		]
	},
	"ALGORITHMS_SEGMENT_TREE_NODE":{
		"prefix": "segment_tree_node",
		"body": [
			"typedef struct Segment_Tree",
			"{",
    		"\tint left_index,right_index,val;",
    		"\tstruct Segment_Tree *left_child,*right_child;",
			"}Segment_Tree;",
		]
	},
	"ALGORITHMS_SEGMENT_TREE_CREATE":{
		"prefix": "segment_tree_create",
		"body": [
			"Segment_Tree * create_segment_tree(int l,int r,vi &vec)",
			"{",
    		"\tSegment_Tree * temp = new Segment_Tree();",
    		"\ttemp->left_index = l;",
    		"\ttemp->right_index = r;",
    		"\tif(l == r)",
    		"\ttemp->val = vec.at(l),temp->left_child = temp->right_child = nullptr;",
    		"\telse",
    		"\t{",
        	"\t\ttemp->left_child = create_segment_tree(l,(l + r) / 2,vec);",
        	"\t\ttemp->right_child = create_segment_tree((l + r) / 2 + 1,r,vec);",
        	"\t\ttemp->val = temp->left_child->val + temp->right_child->val;",
    		"\t}",
    		"\treturn temp;",
			"}"
		]
	},
	"ALGORITHMS_SEGMENT_TREE_UPDATE":{
		"prefix": "segment_tree_update",
		"body": [
			"Segment_Tree * update(Segment_Tree *root,int index,int val)",
			"{",
    		"\tif(root->left_index == root->right_index && root->left_index == index)",
    		"\troot->val += val;",
    		"\telse if(index <= root->right_index && index >= root->left_index)",
    		"\t{",
        	"\t\troot->left_child = update(root->left_child,index,val);",
        	"\t\troot->right_child = update(root->right_child,index,val);",
        	"\t\troot->val = root->left_child->val + root->right_child->val;",
    		"\t}",
    		"\treturn root;",
			"}"
		]
	},
	"ALGORITHMS_SEGMENT_TREE_QUERY":{
		"prefix": "segment_tree_query",
		"body": [
			"int Segment_Tree_query(Segment_Tree * root,int l,int r)",
			"{",
    		"\tif(root->left_index > r || root->right_index < l)",
    		"\treturn 0;",
    		"\telse if(root->left_index >= l && root->right_index <= r)",
    		"\treturn root->val;",
    		"\telse",
    		"\treturn Segment_Tree_query(root->left_child,l,r) + Segment_Tree_query(root->right_child,l,r);",
			"}"
		]
	},
	"ALGORITHMS_MERGE_SORT":{
		"prefix": "merge_sort",
		"body": [
			"void merge_sort(vi &vec,int l,int r)",
			"{",
    		"\tif(l == r)",
    		"\treturn;",
    		"\tint mid = (l + r) / 2;",
    		"\tvi left(mid+1);",
    		"\tvi right(r-mid);",
    		"\tf(i,0,mid+1)",
    		"\tleft.at(i) = vec.at(i);",
    		"\tf(i,mid+1,r+1)",
    		"\tright.at(i-mid-1) = vec.at(i);",
	    	"\tmerge_sort(left,0,mid);",
    		"\tmerge_sort(right,0,r-mid-1);",
    		"\tmerge(vec,left,right,mid + 1,r-mid);",
			"}"
		]
	},
	"ALGORITHMS_MERGE":{
		"prefix": "merge",
		"body": [
			"void merge(vi &vec,vi &left,vi &right,int left_size,int right_size)",
			"{",
    		"\tint le = 0, ri = 0;",
    		"\tf(i,0,left_size + right_size)",
    		"\tif(left.at(le) < right.at(ri))",
    		"\t{",
        	"\t\tvec.at(i) = left.at(le);",
        	"\t\tle++;",
        	"\t\tif(le == left_size)",
        	"\t\t{",
            "\t\t\twhile(ri != right_size)",
            "\t\t\tvec.at(++i) = right.at(ri++);",
            "\t\t\tbreak;",
        	"\t\t}",
    		"\t}",
    		"\telse",
    		"\t{",
        	"\t\tvec.at(i) = right.at(ri);",
        	"\t\tri++;",
        	"\t\tif(ri == right_size)",
        	"\t\t{",
            "\t\twhile(le != left_size)",
            "\t\tvec.at(++i) = left.at(le++);",
            "\t\tbreak;",
        	"\t\t}",
    		"\t}",
			"}"	
		]
	},
	"ALGORITHMS_MATRIX_EXPONENTIATION":{
		"prefix": "matrix_exponentiation",
		"body": [
			"vvi matrix_exponentiation(vvi &matrix,int n)",
			"{",
    		"\tif(n == 0)",
    		"\t{", 
        	"\t\tvvi identity_matrix(matrix.size(),vi(matrix.size()));",
        	"\t\tf(i,0,matrix.size())",
        	"\t\tidentity_matrix[i][i] = 1;",
        	"\t\treturn identity_matrix;",
    		"\t}",
    		"\tvvi temp(matrix.size(),vi(matrix.size()));",
	    	"\ttemp = multiply(matrix,matrix);",
    		"\tvvi mat(matrix.size(),vi(matrix.size()));",
	    	"\tmat = matrix_exponentiation(temp,n / 2);",
    		"\tif(n & 1)", 
    		"\treturn multiply(matrix,mat);",
    		"\treturn mat;",
			"}"
		]
	},
	"ALGORITHMS_MATRIX_EXPONENTIATION_MULTIPLY":{
		"prefix": "multiply",
		"body": [
			"vvi multiply(vvi &A,vvi &B)",
			"{",
    		"\tvvi result(A.size(),vi(A.size()));",
    		"\tf(i,0,A.size())",
    		"\tf(j,0,B.size())",
   	 		"\tresult[i][j] = mul(A,B,i,j,A.size());",
    		"\treturn result;",
			"}"
		]
	},
	"ALGORITHMS_MATRIX_EXPONENTIATION_MUL":{
		"prefix": "mul",
		"body": [
			"int mul(vvi &A, vvi &B, int i, int j, int k)",
			"{",
   	 		"\tint sum = 0;",
    		"\tf(t,0,k)",
    		"\tsum = (sum % inf + (1LL * (A[i][t] % inf) * (B[t][j] % inf)) % inf) % inf;",
    		"\treturn sum;",
			"}"	
		]
	}
}
