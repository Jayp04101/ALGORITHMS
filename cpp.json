{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "Competitive programming template": {
    "prefix": "my_template",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define inf 1000000007",
      "\n\n\n\n\n\n",
      "int main()",
      "{",
      "\tios_base::sync_with_stdio(false);",
      "\tcin.tie(NULL);",
      "\tcout.tie(NULL);",
      "\tint t;",
      "\tcin >> t;",
      "\twhile (t--)",
      "\t{",
      "",
      "\t}",
      "\treturn 0;",
      "}"
    ]
  },
  "ALGORITHMS_BINARY_EXPONENTIATION": {
    "prefix": "binary_exponentiation",
    "body": [
      "ll binary_exponentiation(const ll &a,const ll &n)",
      "{",
      "\tif(n == 0)",
      "\treturn 1;",
      "\tif(n & 1)",
      "\treturn (a % inf) * (binary_exponentiation((a % inf) * (a % inf) % inf,n / 2) % inf) % inf;",
      "\treturn binary_exponentiation((a % inf) * (a % inf) % inf,n / 2) % inf;",
      "}"
    ]
  },
  "ALGORITHMS_DSU_ROOT": {
    "prefix": "dsu_root",
    "body": [
      "int dsu_root(vector<int> &vec,int i)",
      "{",
      "\twhile(vec[i] != i)",
      "\t{",
      "\t\tvec[i] = vec[vec[i]];",
      "\t\ti = vec[i];",
      "\t}",
      "\treturn i;",
      "}"
    ]
  },
  "ALGORITHMS_DSU_UNION_FIND": {
    "prefix": "dsu_union_find",
    "body": [
      "void dsu_union_find(vector<int> &arr,vector<int> &size,int a,int b)",
      "{",
      "\tint root_a = dsu_root(arr,a);",
      "\tint root_b = dsu_root(arr,b);",
      "\tif(root_a == root_b)",
      "\treturn;",
      "\tif(size[root_a] < size[root_b])",
      "\t{",
      "\t\tsize[root_b] += size[root_a];",
      "\t\tarr[root_a] = root_b;",
      "\t}",
      "\telse",
      "\t{",
      "\t\tsize[root_a] += size[root_b];",
      "\t\tarr[root_b] = root_a;",
      "\t}",
      "}"
    ]
  },
  "ALGORITHMS_SIEVE_OF_ERATOSTHENES": {
    "prefix": "sieve_of_eratosthenes",
    "body": [
      "void sieve_of_eratosthenes(vector<bool> &prime)",
      "{",
      "\tprime[1] = false;",
      "\tfor(int p = 2; p <= 1000; ++p)",
      "\t{",
      "\t\tif(!prime.at(p))",
      "\t\tcontinue;",
      "\t\tfor(int q = p * p; q <= 1000000; q += p)",
      "\t\tprime.at(q) = false;",
      "\t}",
      "}"
    ]
  },
  "ALGORITHMS_DIJKSTRA": {
    "prefix": "dijkstra",
    "body": [
      "void dijkstra(vvpii &city,int src)",
      "{",
      "\tpqpii pq;",
      "\tpq.push({0,src});",
      "\tvector<int> dist(city.size(),INT_MAX),path;",
      "\tvector<bool> spt(city.size());",
      "\tdist[src] = 0;",
      "\tpath.push_back(src);",
      "\tspt[src] = true;",
      "\twhile(!pq.empty())",
      "\t{",
      "\t\tfor(pii node:city[src])",
      "\t\t{",
      "\t\t\tif(spt[node.first] == false && dist[src] + node.second < dist[node.first])",
      "\t\t\tdist[node.first] = dist[src] + node.second,pq.push({dist[node.first],node.first});",
      "\t\t}",
      "\t\twhile(!pq.empty())",
      "\t\t{",
      "\t\t\tpii temp = pq.top();",
      "\t\t\tif(spt[temp.second] == false)",
      "\t\t\t{",
      "\t\t\t\tspt[temp.second] = true;",
      "\t\t\t\tsrc = temp.second;",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tpq.pop();",
      "\t\t}",
      "\t}",
      "}"
    ]
  },
  "ALGORITHMS_SEGMENT_TREE_NODE": {
    "prefix": "segment_tree_node",
    "body": [
      "typedef struct Segment_Tree",
      "{",
      "\tint left_index,right_index,val;",
      "\tstruct Segment_Tree *left_child,*right_child;",
      "}Segment_Tree;"
    ]
  },
  "ALGORITHMS_SEGMENT_TREE_CREATE": {
    "prefix": "segment_tree_create",
    "body": [
      "Segment_Tree * create_segment_tree(int l,int r,vector<int> &vec)",
      "{",
      "\tSegment_Tree * temp = new Segment_Tree();",
      "\ttemp->left_index = l;",
      "\ttemp->right_index = r;",
      "\tif(l == r)",
      "\ttemp->val = vec.at(l),temp->left_child = temp->right_child = nullptr;",
      "\telse",
      "\t{",
      "\t\ttemp->left_child = create_segment_tree(l,(l + r) / 2,vec);",
      "\t\ttemp->right_child = create_segment_tree((l + r) / 2 + 1,r,vec);",
      "\t\ttemp->val = temp->left_child->val + temp->right_child->val;",
      "\t}",
      "\treturn temp;",
      "}"
    ]
  },
  "ALGORITHMS_SEGMENT_TREE_UPDATE": {
    "prefix": "segment_tree_update",
    "body": [
      "Segment_Tree * update(Segment_Tree *root,int index,int val)",
      "{",
      "\tif(root->left_index == root->right_index && root->left_index == index)",
      "\troot->val += val;",
      "\telse if(index <= root->right_index && index >= root->left_index)",
      "\t{",
      "\t\troot->left_child = update(root->left_child,index,val);",
      "\t\troot->right_child = update(root->right_child,index,val);",
      "\t\troot->val = root->left_child->val + root->right_child->val;",
      "\t}",
      "\treturn root;",
      "}"
    ]
  },
  "ALGORITHMS_SEGMENT_TREE_QUERY": {
    "prefix": "segment_tree_query",
    "body": [
      "int Segment_Tree_query(Segment_Tree * root,int l,int r)",
      "{",
      "\tif(root->left_index > r || root->right_index < l)",
      "\treturn 0;",
      "\telse if(root->left_index >= l && root->right_index <= r)",
      "\treturn root->val;",
      "\telse",
      "\treturn Segment_Tree_query(root->left_child,l,r) + Segment_Tree_query(root->right_child,l,r);",
      "}"
    ]
  },
  "ALGORITHMS_MERGE_SORT": {
    "prefix": "merge_sort",
    "body": [
      "void merge_sort(vector<int> &vec,int l,int r)",
      "{",
      "\tif(l == r)",
      "\treturn;",
      "\tint mid = (l + r) / 2;",
      "\tvector<int> left(mid+1);",
      "\tvector<int> right(r-mid);",
      "\tf(i,0,mid+1)",
      "\tleft.at(i) = vec.at(i);",
      "\tf(i,mid+1,r+1)",
      "\tright.at(i-mid-1) = vec.at(i);",
      "\tmerge_sort(left,0,mid);",
      "\tmerge_sort(right,0,r-mid-1);",
      "\tmerge(vec,left,right,mid + 1,r-mid);",
      "}"
    ]
  },
  "ALGORITHMS_MERGE": {
    "prefix": "merge",
    "body": [
      "void merge(vector<int> &vec,vector<int> &left,vector<int> &right,int left_size,int right_size)",
      "{",
      "\tint le = 0, ri = 0;",
      "\tf(i,0,left_size + right_size)",
      "\tif(left.at(le) < right.at(ri))",
      "\t{",
      "\t\tvec.at(i) = left.at(le);",
      "\t\tle++;",
      "\t\tif(le == left_size)",
      "\t\t{",
      "\t\t\twhile(ri != right_size)",
      "\t\t\tvec.at(++i) = right.at(ri++);",
      "\t\t\tbreak;",
      "\t\t}",
      "\t}",
      "\telse",
      "\t{",
      "\t\tvec.at(i) = right.at(ri);",
      "\t\tri++;",
      "\t\tif(ri == right_size)",
      "\t\t{",
      "\t\twhile(le != left_size)",
      "\t\tvec.at(++i) = left.at(le++);",
      "\t\tbreak;",
      "\t\t}",
      "\t}",
      "}"
    ]
  },
  "ALGORITHMS_MATRIX_EXPONENTIATION": {
    "prefix": "matrix_exponentiation",
    "body": [
      "vector<vector<int>> matrix_exponentiation(vector<vector<int>> &matrix,int n)",
      "{",
      "\tif(n == 0)",
      "\t{",
      "\t\tvector<vector<int>> identity_matrix(matrix.size(),vector<int>(matrix.size()));",
      "\t\tf(i,0,matrix.size())",
      "\t\tidentity_matrix[i][i] = 1;",
      "\t\treturn identity_matrix;",
      "\t}",
      "\tvector<vector<int>> temp(matrix.size(),vector<int>(matrix.size()));",
      "\ttemp = multiply(matrix,matrix);",
      "\tvector<vector<int>> mat(matrix.size(),vector<int>(matrix.size()));",
      "\tmat = matrix_exponentiation(temp,n / 2);",
      "\tif(n & 1)",
      "\treturn multiply(matrix,mat);",
      "\treturn mat;",
      "}"
    ]
  },
  "ALGORITHMS_MATRIX_EXPONENTIATION_MULTIPLY": {
    "prefix": "multiply",
    "body": [
      "vector<vector<int>> multiply(vector<vector<int>> &A,vector<vector<int>> &B)",
      "{",
      "\tvector<vector<int>> result(A.size(),vector<int>(A.size()));",
      "\tf(i,0,A.size())",
      "\tf(j,0,B.size())",
      "\tresult[i][j] = mul(A,B,i,j,A.size());",
      "\treturn result;",
      "}"
    ]
  },
  "ALGORITHMS_MATRIX_EXPONENTIATION_MUL": {
    "prefix": "mul",
    "body": [
      "int mul(vector<vector<int>> &A, vector<vector<int>> &B, int i, int j, int k)",
      "{",
      "\tint sum = 0;",
      "\tf(t,0,k)",
      "\tsum = (sum % inf + (1LL * (A[i][t] % inf) * (B[t][j] % inf)) % inf) % inf;",
      "\treturn sum;",
      "}"
    ]
  },
  "ALGORITHMS_ARTICULATION_POINTS": {
    "prefix": "articulation_points",
    "body": [
      "void articulation_points(int src, vector<vector<int>> &graph, vector<int> &disc, vector<int> &low, vector<bool> &visited, vector<bool> &ap, vector<int> &parent)",
      "{",
      "\tint child = 0;",
      "\tvisited[src] = true;",
      "\tdisc[src] = low[src] = ++discovery_time;",
      "\tfor (int node : graph[src])",
      "\tif (visited[node])",
      "\t{",
      "\t\tif (node ^ parent[src])",
      "\t\tlow[src] = min(low[src], disc[node]);",
      "\t}",
      "\telse",
      "\t{",
      "\t\t++child;",
      "\t\tparent[node] = src;",
      "\t\tarticulation_points(node, graph, disc, low, visited, ap, parent);",
      "\t\tlow[src] = min(low[src], low[node]);",
      "\t\tif (parent[src] == -1)",
      "\t\t{",
      "\t\t\tif (child > 1)",
      "\t\t\tap[src] = true;",
      "\t\t}",
      "\t\telse if (low[node] >= disc[src])",
      "\t\tap[src] = true;",
      "\t}",
      "}"
    ]
  },
  "ALGORITHMS_BRIDGES": {
    "prefix": "bridges",
    "body": [
      "void bridges(int src, vector<vector<int>> &graph, vector<int> &disc, vector<int> &low, vector<bool> &visited, int parent, vector<pair<int, int>> &result)",
      "{",
      "\tstatic int discovery_time;",
      "\tvisited[src] = true;",
      "\tdisc[src] = low[src] = ++discovery_time;",
      "\tfor (int node : graph[src])",
      "\tif (visited[node])",
      "\t{",
      "\t\tif (node ^ parent)",
      "\t\tlow[src] = min(low[src], disc[node]);",
      "\t\tif (disc[src] < disc[node] && low[node] > disc[src])",
      "\t\tresult.push_back({src, node});",
      "\t}",
      "\telse",
      "\t{",
      "\t\tbridges(node, graph, disc, low, visited, src, result);",
      "\t\tlow[src] = min(low[src], low[node]);",
      "\t\tif (low[node] > disc[src])",
      "\t\tresult.push_back({src, node});",
      "\t}",
      "}"
    ]
  }
}
